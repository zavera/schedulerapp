====
    Copyright (c) 2015-2016, President and Fellows of Harvard College

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
    EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
====

=====================================================
BACK-END TEST STRATEGIES FOR SCHEDULER 3.7 AND BEYOND
=====================================================

"Database-Transactional" tests
------------------------------

Examples of "Database-Transactional" tests are:

* edu.harvard.catalyst.scheduler.service.AppointmentServiceTransactionalTest
* edu.harvard.catalyst.scheduler.service.StudyServiceTransactionalTest

They make use of the following superclass:

* edu.harvard.catalyst.scheduler.AbstractSpringWiredHibernateTest

"Database-Transactional" tests, for lack of a better word, test atomic database
transactions, as performed from the service layer. A set of database populator
utilities are able to quickly create entities in order to populate the database
to its pre-existing state.

AbstractSpringWiredHibernateTest is an abstract class which encapsulates
an auto-wired SessionFactory, and provides basic save() and delete() methods
for creating and removing entities from the database.

With the use of a HQL-compatible in-memory database such as H2, one can
write tests which (1) verify end-to-end atomic transformation of the database data
in response to calls to the service layer (leaving just the resource layer's
simple data preparation functionality to test separately), (2) stimulate and
verify the HQL queries, and (3) execute rapidly thanks to the use of an
in-memory database (as opposed to running against a real SQL database engine
like MySQL)


Database Populator
------------------

A utility is provided for populating the database with the entities needed to
set up and run a "Database-Transactional" test:

* edu.harvard.catalyst.scheduler.util.dbpopulator.DbPopulator

The DataPopulator object holds pointers to specialized data populators, one per
entity class. Each populator has methods of any one of three types:

1. Methods which populate a single entity, and where all the needed objects are
   provided by the caller (e.g. populateOne());

2. Methods which populate a given number of entities using a loop which
   calls a method to populate a single entity (e.g. populateMany());

3. Methods which populate the database with one entity as well as (some of)
   its dependencies. (e.g. populateOneWithDependencies()).
   There can be many versions of this kind of method,
   useful for various tests. Not all tests will need all the dependencies
   populated.

Note that there is a lot of room for making arbitrary decisions w.r.t. what parts
of an entity get populated or not, or whether multiple entities will share
underlying dependencies as opposed to each having their own, etc. One way to manage
this state of affairs is to write specialized populator methods as needed,
and periodically refactor and simplify them if possible.

Note that all the above methods for populating the database with entities
take an integer input argument usually called "entityNumber" or
"startingEntityNumber". This number is NOT related to the database ID
of the generated entities. The database ID is generated by the database engine,
and the client Java test code has no control over the value of the ID's.
However, the "entityNumber" argument is used to generate a unique string for one of
the unique-valued String attributes of the entity, which can then be used
to disambiguate between multiple generated entities in the test code.
This becomes especially useful when writing the code to verify the side-effects
of a method under test.

A further level of encapsulation could be to have configurable test harnesses
for each the various services, or even sets of methods of a service which need
more or less the same database set-up. This would reduce the amount of boilerplate
code to be written for each individual test.
